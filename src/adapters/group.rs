//! Labeled group macro for creating sets of related counters with labels.
//!
//! This module provides the [`labeled_group!`] macro for creating groups of
//! counters that share a metric name but have different label values.
//!
//! # Example
//!
//! ```rust
//! use contatori::labeled_group;
//! use contatori::counters::unsigned::Unsigned;
//! use contatori::counters::Observable;
//!
//! labeled_group!(
//!     HttpRequests,
//!     "http_requests",
//!     "method",
//!     value: Unsigned,
//!     get: "GET": Unsigned,
//!     post: "POST": Unsigned,
//! );
//!
//! static HTTP: HttpRequests = HttpRequests::new();
//!
//! // Increment counters with direct access
//! HTTP.value.add(1);
//! HTTP.get.add(1);
//!
//! // Export via expand()
//! for entry in HTTP.expand() {
//!     println!("{}: {:?} = {}", entry.name, entry.label, entry.value);
//! }
//! ```

/// Creates a labeled group of counters with compile-time known structure.
///
/// This macro generates a struct containing multiple counters, each associated
/// with a label value. The generated struct implements the [`Observable`] trait
/// and its `expand()` method returns all sub-counters with their labels.
///
/// # Syntax
///
/// ```rust,ignore
/// labeled_group!(
///     StructName,           // Name of the generated struct
///     "metric_name",        // The metric name for all counters
///     "label_key",          // The label key (e.g., "method")
///     value: CounterType,   // MANDATORY unlabeled counter (base metric)
///
///     // Optional counters with labels:
///     field_name: "label_value": CounterType,
/// );
/// ```
///
/// # Semantics
///
/// - **`value` field**: The mandatory unlabeled counter represents the base metric value.
///   It is semantically independent from labeled counters and should be incremented
///   based on your application logic.
/// - **Labeled fields**: Optional breakdowns that provide dimensional views of the metric.
///   These are independent counters, NOT automatically aggregated.
///
/// # Example
///
/// ```rust
/// use contatori::labeled_group;
/// use contatori::counters::unsigned::Unsigned;
/// use contatori::counters::Observable;
///
/// labeled_group!(
///     HttpRequests,
///     "http_requests",
///     "method",
///     value: Unsigned,              // Base metric (mandatory)
///     get: "GET": Unsigned,
///     post: "POST": Unsigned,
///     put: "PUT": Unsigned,
///     delete: "DELETE": Unsigned,
/// );
///
/// static HTTP: HttpRequests = HttpRequests::new();
///
/// // Direct field access for incrementing
/// HTTP.value.add(1);  // Increment base metric
/// HTTP.get.add(1);    // Increment GET counter
///
/// // The expand() method returns:
/// // - http_requests (no label) = value
/// // - http_requests{method="GET"} = get
/// // - http_requests{method="POST"} = post
/// // etc.
/// ```
///
/// # Prometheus Output
///
/// When used with the Prometheus observer, the output will be:
///
/// ```text
/// http_requests 100
/// http_requests{method="GET"} 50
/// http_requests{method="POST"} 30
/// http_requests{method="PUT"} 15
/// http_requests{method="DELETE"} 5
/// ```
#[macro_export]
macro_rules! labeled_group {
    (
        $name:ident,
        $metric:literal,
        $label_key:literal,
        $main_field:ident : $value_ty:ty,
        $($rest:tt)*
    ) => {
        $crate::labeled_group!(@parse
            $name,
            $metric,
            $label_key,
            $main_field,
            $value_ty,
            [],    // labeled fields accumulator
            $($rest)*
        );
    };

    // Parse labeled field: `field: "label": Type,`
    (@parse
        $name:ident,
        $metric:literal,
        $label_key:literal,
        $main_field:ident,
        $value_ty:ty,
        [$($labeled:tt)*],
        $field:ident : $label_val:literal : $ty:ty,
        $($rest:tt)*
    ) => {
        $crate::labeled_group!(@parse
            $name,
            $metric,
            $label_key,
            $main_field,
            $value_ty,
            [$($labeled)* ($field, $label_val, $ty)],
            $($rest)*
        );
    };

    // Terminal case - generate the struct
    (@parse
        $name:ident,
        $metric:literal,
        $label_key:literal,
        $main_field:ident,
        $value_ty:ty,
        [$(($lfield:ident, $lval:literal, $lty:ty))*],
    ) => {
        /// A labeled group of counters.
        ///
        /// Generated by the `labeled_group!` macro.
        pub struct $name {
            pub $main_field: $value_ty,
            $(pub $lfield: $lty,)*
        }

        impl $name {
            /// Creates a new instance with all counters initialized.
            pub const fn new() -> Self {
                Self {
                    $main_field: <$value_ty>::new(),
                    $($lfield: <$lty>::new(),)*
                }
            }

            /// Returns the metric name for this group.
            #[inline]
            #[allow(dead_code)]
            pub const fn metric_name(&self) -> &'static str {
                $metric
            }

            /// Returns the label key for this group.
            #[inline]
            #[allow(dead_code)]
            pub const fn label_key(&self) -> &'static str {
                $label_key
            }
        }

        impl $crate::counters::Observable for $name {
            fn name(&self) -> &'static str {
                $metric
            }

            fn value(&self) -> $crate::counters::CounterValue {
                self.$main_field.value()
            }

            fn metric_kind(&self) -> $crate::counters::MetricKind {
                $crate::counters::MetricKind::Gauge
            }

            fn expand(&self) -> Vec<$crate::counters::ObservableEntry> {
                const LABELS:  &[&'static str] = &[ $( $lval ),* ];
                let mut entries = Vec::with_capacity(1 + LABELS.len());

                // Add the mandatory unlabeled counter using the custom field name
                entries.push($crate::counters::ObservableEntry {
                    name: $metric,
                    label: None,
                    value: self.$main_field.value(),
                    metric_kind: self.$main_field.metric_kind(),
                });

                // Add labeled counters
                $(
                    entries.push($crate::counters::ObservableEntry {
                        name: $metric,
                        label: Some(($label_key, $lval)),
                        value: self.$lfield.value(),
                        metric_kind: self.$lfield.metric_kind(),
                    });
                )*

                entries
            }
        }

        impl ::std::fmt::Debug for $name {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.debug_struct(stringify!($name))
                    .field(stringify!($main_field), &self.$main_field)
                    $(.field(stringify!($lfield), &self.$lfield))*
                    .finish()
            }
        }

        impl Default for $name {
            fn default() -> Self {
                Self::new()
            }
        }
    };
}

#[cfg(test)]
mod tests {
    use crate::counters::unsigned::Unsigned;
    use crate::counters::Observable;

    labeled_group!(
        TestRequests,
        "test_requests",
        "method",
        value: Unsigned,
        get: "GET": Unsigned,
        post: "POST": Unsigned,
    );

    #[test]
    fn test_new() {
        let requests = TestRequests::new();
        assert_eq!(requests.metric_name(), "test_requests");
        assert_eq!(requests.label_key(), "method");
    }

    #[test]
    fn test_direct_access() {
        let requests = TestRequests::new();
        requests.value.add(10);
        requests.get.add(5);
        requests.post.add(3);

        assert_eq!(requests.value.value().as_u64(), 10);
        assert_eq!(requests.get.value().as_u64(), 5);
        assert_eq!(requests.post.value().as_u64(), 3);
    }

    #[test]
    fn test_expand() {
        let requests = TestRequests::new();
        requests.value.add(100);
        requests.get.add(60);
        requests.post.add(40);

        let entries = requests.expand();
        assert_eq!(entries.len(), 3);

        // First entry: value (no label)
        assert_eq!(entries[0].name, "test_requests");
        assert!(entries[0].label.is_none());
        assert_eq!(entries[0].value.as_u64(), 100);

        // Second entry: get with label
        assert_eq!(entries[1].name, "test_requests");
        assert!(entries[1].label.is_some());
        let (key, val) = entries[1].label.unwrap();
        assert_eq!(key, "method");
        assert_eq!(val, "GET");
        assert_eq!(entries[1].value.as_u64(), 60);

        // Third entry: post with label
        assert_eq!(entries[2].name, "test_requests");
        assert!(entries[2].label.is_some());
        let (key, val) = entries[2].label.unwrap();
        assert_eq!(key, "method");
        assert_eq!(val, "POST");
        assert_eq!(entries[2].value.as_u64(), 40);
    }

    #[test]
    fn test_observable_value() {
        let requests = TestRequests::new();
        requests.value.add(100);
        requests.get.add(60);
        requests.post.add(40);

        // value() returns the unlabeled 'value' field directly (not sum)
        assert_eq!(requests.value().as_u64(), 100);
    }

    #[test]
    fn test_observable_name() {
        let requests = TestRequests::new();
        assert_eq!(requests.name(), "test_requests");
    }

    #[test]
    fn test_static_usage() {
        static REQUESTS: TestRequests = TestRequests::new();

        REQUESTS.value.add(1);
        REQUESTS.get.add(1);

        assert_eq!(REQUESTS.value.value().as_u64(), 1);
        assert_eq!(REQUESTS.get.value().as_u64(), 1);
    }

    #[test]
    fn test_debug() {
        let requests = TestRequests::new();
        requests.get.add(42);

        let debug_str = format!("{:?}", requests);
        assert!(debug_str.contains("TestRequests"));
    }

    // Test with value counter independence
    #[test]
    fn test_value_independence() {
        let requests = TestRequests::new();

        // Increment labeled counters
        requests.get.add(50);
        requests.post.add(30);

        // value remains independent
        assert_eq!(requests.value.value().as_u64(), 0);

        // Increment value separately
        requests.value.add(100);
        assert_eq!(requests.value.value().as_u64(), 100);

        // value() returns only the 'value' field
        assert_eq!(requests.value().as_u64(), 100);
    }

    // Test with only value (no labeled counters)
    labeled_group!(
        OnlyValue,
        "only_value",
        "unused",
        value: Unsigned,
    );

    #[test]
    fn test_only_value() {
        let counters = OnlyValue::new();
        counters.value.add(50);

        let entries = counters.expand();
        assert_eq!(entries.len(), 1);
        assert!(entries[0].label.is_none());
        assert_eq!(entries[0].value.as_u64(), 50);

        // Observable::value() returns the 'value' field
        assert_eq!(counters.value().as_u64(), 50);
    }
}
