//! Labeled group macro for creating sets of related counters with labels.
//!
//! This module provides the [`labeled_group!`] macro for creating groups of
//! counters that share a metric name but have different label values.
//!
//! # Example
//!
//! ```rust
//! use contatori::labeled_group;
//! use contatori::counters::unsigned::Unsigned;
//! use contatori::counters::Observable;
//!
//! labeled_group!(
//!     HttpRequests,
//!     "http_requests",
//!     "method",
//!     total: Unsigned,
//!     get: "GET": Unsigned,
//!     post: "POST": Unsigned,
//! );
//!
//! static HTTP: HttpRequests = HttpRequests::new();
//!
//! // Increment counters with direct access
//! HTTP.total.add(1);
//! HTTP.get.add(1);
//!
//! // Export via expand()
//! for entry in HTTP.expand() {
//!     println!("{}: {:?} = {}", entry.name, entry.label, entry.value);
//! }
//! ```

/// Creates a labeled group of counters with compile-time known structure.
///
/// This macro generates a struct containing multiple counters, each associated
/// with a label value. The generated struct implements the [`Observable`] trait
/// and its `expand()` method returns all sub-counters with their labels.
///
/// # Syntax
///
/// ```rust,ignore
/// labeled_group!(
///     StructName,           // Name of the generated struct
///     "metric_name",        // The metric name for all counters
///     "label_key",          // The label key (e.g., "method")
///     
///     // Counters without labels (e.g., total):
///     field_name: CounterType,
///     
///     // Counters with labels:
///     field_name: "label_value": CounterType,
/// );
/// ```
///
/// # Example
///
/// ```rust
/// use contatori::labeled_group;
/// use contatori::counters::unsigned::Unsigned;
/// use contatori::counters::Observable;
///
/// labeled_group!(
///     HttpRequests,
///     "http_requests",
///     "method",
///     total: Unsigned,              // No label - the aggregate
///     get: "GET": Unsigned,
///     post: "POST": Unsigned,
///     put: "PUT": Unsigned,
///     delete: "DELETE": Unsigned,
/// );
///
/// static HTTP: HttpRequests = HttpRequests::new();
///
/// // Direct field access for incrementing
/// HTTP.total.add(1);
/// HTTP.get.add(1);
///
/// // The expand() method returns:
/// // - http_requests (no label) = total
/// // - http_requests{method="GET"} = get
/// // - http_requests{method="POST"} = post
/// // etc.
/// ```
///
/// # Prometheus Output
///
/// When used with the Prometheus observer, the output will be:
///
/// ```text
/// http_requests 100
/// http_requests{method="GET"} 50
/// http_requests{method="POST"} 30
/// http_requests{method="PUT"} 15
/// http_requests{method="DELETE"} 5
/// ```
#[macro_export]
macro_rules! labeled_group {
    (
        $name:ident,
        $metric:literal,
        $label_key:literal,
        $($rest:tt)*
    ) => {
        $crate::labeled_group!(@parse
            $name,
            $metric,
            $label_key,
            [],    // unlabeled fields
            [],    // labeled fields
            $($rest)*
        );
    };

    // Parse unlabeled field: `field: Type,`
    (@parse
        $name:ident,
        $metric:literal,
        $label_key:literal,
        [$($unlabeled:tt)*],
        [$($labeled:tt)*],
        $field:ident : $ty:ty,
        $($rest:tt)*
    ) => {
        $crate::labeled_group!(@parse
            $name,
            $metric,
            $label_key,
            [$($unlabeled)* ($field, $ty)],
            [$($labeled)*],
            $($rest)*
        );
    };

    // Parse labeled field: `field: "label": Type,`
    (@parse
        $name:ident,
        $metric:literal,
        $label_key:literal,
        [$($unlabeled:tt)*],
        [$($labeled:tt)*],
        $field:ident : $label_val:literal : $ty:ty,
        $($rest:tt)*
    ) => {
        $crate::labeled_group!(@parse
            $name,
            $metric,
            $label_key,
            [$($unlabeled)*],
            [$($labeled)* ($field, $label_val, $ty)],
            $($rest)*
        );
    };

    // Terminal case - generate the struct
    (@parse
        $name:ident,
        $metric:literal,
        $label_key:literal,
        [$(($ufield:ident, $uty:ty))*],
        [$(($lfield:ident, $lval:literal, $lty:ty))*],
    ) => {
        /// A labeled group of counters.
        ///
        /// Generated by the `labeled_group!` macro.
        pub struct $name {
            $(pub $ufield: $uty,)*
            $(pub $lfield: $lty,)*
        }

        impl $name {
            /// Creates a new instance with all counters initialized.
            pub const fn new() -> Self {
                Self {
                    $($ufield: <$uty>::new(),)*
                    $($lfield: <$lty>::new(),)*
                }
            }

            /// Returns the metric name for this group.
            #[inline]
            #[allow(dead_code)]
            pub const fn metric_name(&self) -> &'static str {
                $metric
            }

            /// Returns the label key for this group.
            #[inline]
            #[allow(dead_code)]
            pub const fn label_key(&self) -> &'static str {
                $label_key
            }
        }

        impl $crate::counters::Observable for $name {
            fn name(&self) -> &'static str {
                $metric
            }

            fn value(&self) -> $crate::counters::CounterValue {
                // Return sum of all counters as the aggregate value
                let mut total: u64 = 0;
                $(total += self.$ufield.value().as_u64();)*
                $(total += self.$lfield.value().as_u64();)*
                $crate::counters::CounterValue::Unsigned(total)
            }

            fn metric_kind(&self) -> $crate::counters::MetricKind {
                $crate::counters::MetricKind::Gauge
            }

            fn expand(&self) -> Vec<$crate::counters::ObservableEntry> {
                let mut entries = Vec::new();

                // Add unlabeled counters (e.g., total)
                $(
                    entries.push($crate::counters::ObservableEntry {
                        name: $metric,
                        label: None,
                        value: self.$ufield.value(),
                        metric_kind: self.$ufield.metric_kind(),
                    });
                )*

                // Add labeled counters
                $(
                    entries.push($crate::counters::ObservableEntry {
                        name: $metric,
                        label: Some(($label_key, $lval)),
                        value: self.$lfield.value(),
                        metric_kind: self.$lfield.metric_kind(),
                    });
                )*

                entries
            }
        }

        impl ::std::fmt::Debug for $name {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.debug_struct(stringify!($name))
                    $(.field(stringify!($ufield), &self.$ufield))*
                    $(.field(stringify!($lfield), &self.$lfield))*
                    .finish()
            }
        }

        impl Default for $name {
            fn default() -> Self {
                Self::new()
            }
        }
    };
}

#[cfg(test)]
mod tests {
    use crate::counters::unsigned::Unsigned;
    use crate::counters::Observable;

    labeled_group!(
        TestRequests,
        "test_requests",
        "method",
        total: Unsigned,
        get: "GET": Unsigned,
        post: "POST": Unsigned,
    );

    #[test]
    fn test_new() {
        let requests = TestRequests::new();
        assert_eq!(requests.metric_name(), "test_requests");
        assert_eq!(requests.label_key(), "method");
    }

    #[test]
    fn test_direct_access() {
        let requests = TestRequests::new();
        requests.total.add(10);
        requests.get.add(5);
        requests.post.add(3);

        assert_eq!(requests.total.value().as_u64(), 10);
        assert_eq!(requests.get.value().as_u64(), 5);
        assert_eq!(requests.post.value().as_u64(), 3);
    }

    #[test]
    fn test_expand() {
        let requests = TestRequests::new();
        requests.total.add(100);
        requests.get.add(60);
        requests.post.add(40);

        let entries = requests.expand();
        assert_eq!(entries.len(), 3);

        // First entry: total (no label)
        assert_eq!(entries[0].name, "test_requests");
        assert!(entries[0].label.is_none());
        assert_eq!(entries[0].value.as_u64(), 100);

        // Second entry: get with label
        assert_eq!(entries[1].name, "test_requests");
        assert!(entries[1].label.is_some());
        let (key, val) = entries[1].label.unwrap();
        assert_eq!(key, "method");
        assert_eq!(val, "GET");
        assert_eq!(entries[1].value.as_u64(), 60);

        // Third entry: post with label
        assert_eq!(entries[2].name, "test_requests");
        assert!(entries[2].label.is_some());
        let (key, val) = entries[2].label.unwrap();
        assert_eq!(key, "method");
        assert_eq!(val, "POST");
        assert_eq!(entries[2].value.as_u64(), 40);
    }

    #[test]
    fn test_observable_value() {
        let requests = TestRequests::new();
        requests.total.add(100);
        requests.get.add(60);
        requests.post.add(40);

        // value() returns the sum of all counters
        assert_eq!(requests.value().as_u64(), 200);
    }

    #[test]
    fn test_observable_name() {
        let requests = TestRequests::new();
        assert_eq!(requests.name(), "test_requests");
    }

    #[test]
    fn test_static_usage() {
        static REQUESTS: TestRequests = TestRequests::new();

        REQUESTS.total.add(1);
        REQUESTS.get.add(1);

        assert_eq!(REQUESTS.total.value().as_u64(), 1);
        assert_eq!(REQUESTS.get.value().as_u64(), 1);
    }

    #[test]
    fn test_debug() {
        let requests = TestRequests::new();
        requests.get.add(42);

        let debug_str = format!("{:?}", requests);
        assert!(debug_str.contains("TestRequests"));
    }

    // Test with only labeled counters (no total)
    labeled_group!(
        OnlyLabeled,
        "only_labeled",
        "type",
        a: "A": Unsigned,
        b: "B": Unsigned,
    );

    #[test]
    fn test_only_labeled() {
        let counters = OnlyLabeled::new();
        counters.a.add(10);
        counters.b.add(20);

        let entries = counters.expand();
        assert_eq!(entries.len(), 2);
        assert!(entries[0].label.is_some());
        assert!(entries[1].label.is_some());
    }

    // Test with only unlabeled counter
    labeled_group!(
        OnlyUnlabeled,
        "only_unlabeled",
        "unused",
        total: Unsigned,
    );

    #[test]
    fn test_only_unlabeled() {
        let counters = OnlyUnlabeled::new();
        counters.total.add(50);

        let entries = counters.expand();
        assert_eq!(entries.len(), 1);
        assert!(entries[0].label.is_none());
        assert_eq!(entries[0].value.as_u64(), 50);
    }
}